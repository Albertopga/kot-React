'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extract;

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _babelTraverse = require('babel-traverse');

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function extract(file) {
  // iterate through files / dependency tree
  // parse with babel / detect <Match entry, extract sub entry='' as deps
  // return { [entry] : [, deps] }
  var ret = {};
  var dir = path.dirname(file);
  var files = fs.readdirSync(dir);
  files.forEach(function (f) {
    var ext = path.extname(f);
    if (ext === '.js') {
      (function () {
        var src = fs.readFileSync(path.join(dir, f), 'utf8');
        var ast = babylon.parse(src, {
          sourceType: 'module',
          plugins: ['jsx', 'flow', 'doExpressions', 'objectRestSpread', 'decorators', 'classProperties', 'exportExtensions', 'asyncGenerators', 'functionBind', 'functionSent']
        });
        (0, _babelTraverse2.default)(ast, {
          enter: function enter(x) {
            if (x.type === 'JSXElement' && x.node.openingElement.name.name === 'Match') {

              var attrs = x.node.openingElement.attributes;
              var hasPattern = attrs.filter(function (attr) {
                return attr.name.name === 'pattern';
              });
              if (hasPattern.length > 0) {
                hasPattern = hasPattern[0].value.value;
              } else {
                hasPattern = undefined;
              }
              if (hasPattern) {
                // pull out entries 
                var entries = src.substring(x.node.start, x.node.end);
                var regex = /entry\=['"](.*?)['"]/g;
                var m = void 0,
                    matches = [];
                while ((m = regex.exec(entries)) !== null) {
                  matches.push(m[1]);
                }
                if (matches.length > 0) {
                  ret[hasPattern] = ret[hasPattern] || [];
                  ret[hasPattern] = ret[hasPattern].concat(matches);
                }
              }
            }
          }
        });
      })();
    }
  });
  return ret;
}