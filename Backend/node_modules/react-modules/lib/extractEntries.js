'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extract;

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _babelTraverse = require('babel-traverse');

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function extract(file) {
  // iterate through files / dependency tree
  // parse with babel / detect <modules entry, extract requires as deps
  // return { [entry] : [, deps] }
  var ret = {};
  var dir = path.dirname(file);
  var files = fs.readdirSync(dir);
  files.forEach(function (f) {
    var ext = path.extname(f);
    if (ext === '.js') {
      (function () {
        var src = fs.readFileSync(path.join(dir, f), 'utf8');
        var ast = babylon.parse(src, {
          sourceType: 'module',
          plugins: ['jsx', 'flow', 'doExpressions', 'objectRestSpread', 'decorators', 'classProperties', 'exportExtensions', 'asyncGenerators', 'functionBind', 'functionSent']
        });
        (0, _babelTraverse2.default)(ast, {
          enter: function enter(x) {
            if (x.type === 'JSXElement' && x.node.openingElement.name.name === 'Modules') {
              var attrs = x.node.openingElement.attributes;
              var hasEntry = attrs.filter(function (attr) {
                return attr.name.name === 'entry';
              });
              if (hasEntry.length > 0) {
                hasEntry = hasEntry[0].value.value;
              } else {
                hasEntry = undefined;
              }
              if (hasEntry) {
                var hasLoad = attrs.filter(function (attr) {
                  return attr.name.name === 'load';
                });
                if (hasLoad.length > 0) {
                  hasLoad = hasLoad[0].value.expression;
                } else {
                  hasLoad = undefined;
                }

                // parse hasload for all require calls
                if (hasLoad) {
                  var reqs = src.substring(hasLoad.start, hasLoad.end);
                  var regex = /require\(['"](.*?)['"]\)/g;
                  var m = void 0,
                      matches = [];
                  while ((m = regex.exec(reqs)) !== null) {
                    matches.push(path.join(dir, m[1]));
                  }
                  if (matches.length > 0) {
                    ret[hasEntry] = ret[hasEntry] || [];
                    ret[hasEntry] = ret[hasEntry].concat(matches);
                  }
                }
              }
            }
          }
        });
      })();
    }
  });
  Object.keys(ret).forEach(function (key) {
    ret[key].push(file);
  });
  return ret;
}